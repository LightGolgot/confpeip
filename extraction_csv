import csv
import math

"""
EXTRACTION DES DONNEES DE PLUVIOMETRIE
On utilise ce dataset comme source : https://www.data.gouv.fr/fr/datasets/pluviometrie/

Les données sont celles des Hauts-de-Seine, j'ai choisis arbitrairement les données d'Asnière
puisque c'est à côté de chez moi à Paris (on peut changer via le premier argument de get_csv).

La valeure de la pluviométrie est en mm/m^3 habituellement, on doit donc rentrer le diamètre du pot de
la plante pour trouver la quantité.

ATTENTION : Les valeurs d'arrosage de certains jours sont assez élevés, pour la survie de la plante 
il serait judicieux d'arroser via un brumisateur ou une merde dans le genre parceque sinon on risque de la noyer !

La notice finale garde les dates comme elles le sont dans le CSV d'origine, je corrigerais après en avoir
discuter avec gauthier.

PS : excusez moi d'avance pour l'optimisation du programme qui est surement désastreuse :o
"""

class pluviometrie:
    def __init__(self, c, cote):
        self.rows = []
        self.surface = cote**2
        print(self.surface)
        self.months = ['janvier', 'février', 'mars', 'avril', 'mai', 'juin', 'juillet', 'août', 'septembre', 'octobre', 'novembre', 'décembre']
        with open(c, 'r') as file:
            csvreader = csv.reader(file, delimiter=';')
            self.header = next(csvreader)
            for row in csvreader:
                self.rows.append(row)

    def date(self, s):
        a = s[0:4]
        m = s[5:7]
        j = s[8:10]
        return [int(a), int(m), int(j)]

    def read_date(self, s):

        a = s[0]
        m = self.months[s[1]-1]
        j = s[2]
        d = str(j) + ' ' + str(m)
        return d

    def crop(self, R, y):
        return [r for r in R if r[0][0] == y]

    def get_rain_from_row(self, n):
        R = []
        for r in self.rows:
            R.append([self.date(r[0]),r[n]]) if r[n] != '' else R.append([self.date(r[0]), 0])
        return R

    def set_readable_date(self, R):
        for r in R:
            r[0] = self.read_date(r[0])
        return R

    def quantity(self, r):
        return int(round(float(r[1])*self.surface, 3)*10e3)

    def add_quantity(self, R):
        for i in range(len(R)):
            T = R[i]
            T.append(self.quantity(R[i]))
            R[i] = T
        return R

    def crop_season(self, R, m1, m2):
        return [r for r in R if r[0][1] >= m1 and r[0][1] <= m2]

    def begin_at(self, R, month):
        for i in range(len(R)):
            R[i][0][1] += month-R[i][0][1]
        return R

    def get_csv(self, n, y, m1, m2, month_to_begin, c):
        R = self.get_rain_from_row(n)
        R = self.crop(R,y)
        R = self.crop_season(R, m1, m2)
        R = self.begin_at(R, month_to_begin)
        R = self.set_readable_date(R)
        R = self.add_quantity(R)
        print(R)
        header = ['date', 'pluviométrie', 'quantité d\'arrosage (en mL)']
        with open(c, 'w') as file:
            csvwriter = csv.writer(file, delimiter=',')
            csvwriter.writerow(header)
            csvwriter.writerows(R)
            file.close()
        print('fichier écrit avec succès !')
        return R

data = pluviometrie('dataset/pluviometrie.csv', 0.12)
data.get_csv(3, 2015, 3, 5, 2, 'dataset/notice_arrosage.csv') #Paramètres utilisés pour créer le fichier notice_arrosage !

"""
Dans l'ordre les arguments de la classe pluviométrie sont :
- Chemin vers le dataset
- Côté du bac contenant les plantes (12 cm pour notre expérience)

Dans l'ordre les arguments du module get_csv sont :
- Numéro de colonne des données que l'on extrait (correspond à la localisation, 4 = Asnière)
- Année des mesures
- Mois du début de mesures
- Mois fin des mesures
- Le mois à partir duquelle on commence à écrire les mesures dans la notice (2 = fevrier)
- Localisation du fichier final (pas nécessaire que ce dernier existe)
"""
